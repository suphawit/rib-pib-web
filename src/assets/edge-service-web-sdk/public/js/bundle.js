!function(n){var e={};function t(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return n[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)t.d(r,o,function(e){return n[e]}.bind(null,o));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=1)}([function(n,e){n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},function(n,e,t){t(2),t(4),t(6),t(8),t(10),t(12),t(14),t(16)},function(n,e,t){t(0)(t(3))},function(n,e){n.exports="/**\n * @license\n * deferred-js https://github.com/warpdesign/deferred-js#licence\n * Copyright 2012 Â© Nicolas Ramz\n * Released under the MIT license\n */\n(function (global) {\n  function isArray(arr) {\n    return Object.prototype.toString.call(arr) === '[object Array]';\n  }\n\n  function foreach(arr, handler) {\n    if (isArray(arr)) {\n      for (var i = 0; i < arr.length; i++) {\n        handler(arr[i]);\n      }\n    } else handler(arr);\n  }\n\n  function D(fn) {\n    var status = 'pending',\n        doneFuncs = [],\n        failFuncs = [],\n        progressFuncs = [],\n        resultArgs = null,\n        _promise = {\n      done: function done() {\n        for (var i = 0; i < arguments.length; i++) {\n          // skip any undefined or null arguments\n          if (!arguments[i]) {\n            continue;\n          }\n\n          if (isArray(arguments[i])) {\n            var arr = arguments[i];\n\n            for (var j = 0; j < arr.length; j++) {\n              // immediately call the function if the deferred has been resolved\n              if (status === 'resolved') {\n                arr[j].apply(this, resultArgs);\n              }\n\n              doneFuncs.push(arr[j]);\n            }\n          } else {\n            // immediately call the function if the deferred has been resolved\n            if (status === 'resolved') {\n              arguments[i].apply(this, resultArgs);\n            }\n\n            doneFuncs.push(arguments[i]);\n          }\n        }\n\n        return this;\n      },\n      fail: function fail() {\n        for (var i = 0; i < arguments.length; i++) {\n          // skip any undefined or null arguments\n          if (!arguments[i]) {\n            continue;\n          }\n\n          if (isArray(arguments[i])) {\n            var arr = arguments[i];\n\n            for (var j = 0; j < arr.length; j++) {\n              // immediately call the function if the deferred has been resolved\n              if (status === 'rejected') {\n                arr[j].apply(this, resultArgs);\n              }\n\n              failFuncs.push(arr[j]);\n            }\n          } else {\n            // immediately call the function if the deferred has been resolved\n            if (status === 'rejected') {\n              arguments[i].apply(this, resultArgs);\n            }\n\n            failFuncs.push(arguments[i]);\n          }\n        }\n\n        return this;\n      },\n      always: function always() {\n        return this.done.apply(this, arguments).fail.apply(this, arguments);\n      },\n      progress: function progress() {\n        for (var i = 0; i < arguments.length; i++) {\n          // skip any undefined or null arguments\n          if (!arguments[i]) {\n            continue;\n          }\n\n          if (isArray(arguments[i])) {\n            var arr = arguments[i];\n\n            for (var j = 0; j < arr.length; j++) {\n              // immediately call the function if the deferred has been resolved\n              if (status === 'pending') {\n                progressFuncs.push(arr[j]);\n              }\n            }\n          } else {\n            // immediately call the function if the deferred has been resolved\n            if (status === 'pending') {\n              progressFuncs.push(arguments[i]);\n            }\n          }\n        }\n\n        return this;\n      },\n      then: function then() {\n        // fail callbacks\n        if (arguments.length > 1 && arguments[1]) {\n          this.fail(arguments[1]);\n        } // done callbacks\n\n\n        if (arguments.length > 0 && arguments[0]) {\n          this.done(arguments[0]);\n        } // notify callbacks\n\n\n        if (arguments.length > 2 && arguments[2]) {\n          this.progress(arguments[2]);\n        }\n      },\n      promise: function promise(obj) {\n        if (obj == null) {\n          return _promise;\n        } else {\n          for (var i in _promise) {\n            obj[i] = _promise[i];\n          }\n\n          return obj;\n        }\n      },\n      state: function state() {\n        return status;\n      },\n      debug: function debug() {\n        console.log('[debug]', doneFuncs, failFuncs, status);\n      },\n      isRejected: function isRejected() {\n        return status === 'rejected';\n      },\n      isResolved: function isResolved() {\n        return status === 'resolved';\n      },\n      pipe: function pipe(done, fail, progress) {\n        return D(function (def) {\n          foreach(done, function (func) {\n            // filter function\n            if (typeof func === 'function') {\n              deferred.done(function () {\n                var returnval = func.apply(this, arguments); // if a new deferred/promise is returned, its state is passed to the current deferred/promise\n\n                if (returnval && typeof returnval === 'function') {\n                  returnval.promise().then(def.resolve, def.reject, def.notify);\n                } else {\n                  // if new return val is passed, it is passed to the piped done\n                  def.resolve(returnval);\n                }\n              });\n            } else {\n              deferred.done(def.resolve);\n            }\n          });\n          foreach(fail, function (func) {\n            if (typeof func === 'function') {\n              deferred.fail(function () {\n                var returnval = func.apply(this, arguments);\n\n                if (returnval && typeof returnval === 'function') {\n                  returnval.promise().then(def.resolve, def.reject, def.notify);\n                } else {\n                  def.reject(returnval);\n                }\n              });\n            } else {\n              deferred.fail(def.reject);\n            }\n          });\n        }).promise();\n      }\n    },\n        deferred = {\n      resolveWith: function resolveWith(context) {\n        if (status === 'pending') {\n          status = 'resolved';\n          var args = resultArgs = arguments.length > 1 ? arguments[1] : [];\n\n          for (var i = 0; i < doneFuncs.length; i++) {\n            doneFuncs[i].apply(context, args);\n          }\n        }\n\n        return this;\n      },\n      rejectWith: function rejectWith(context) {\n        if (status === 'pending') {\n          status = 'rejected';\n          var args = resultArgs = arguments.length > 1 ? arguments[1] : [];\n\n          for (var i = 0; i < failFuncs.length; i++) {\n            failFuncs[i].apply(context, args);\n          }\n        }\n\n        return this;\n      },\n      notifyWith: function notifyWith(context) {\n        if (status === 'pending') {\n          var args = resultArgs = arguments.length > 1 ? arguments[1] : [];\n\n          for (var i = 0; i < progressFuncs.length; i++) {\n            progressFuncs[i].apply(context, args);\n          }\n        }\n\n        return this;\n      },\n      resolve: function resolve() {\n        return this.resolveWith(this, arguments);\n      },\n      reject: function reject() {\n        return this.rejectWith(this, arguments);\n      },\n      notify: function notify() {\n        return this.notifyWith(this, arguments);\n      }\n    };\n\n    var obj = _promise.promise(deferred);\n\n    if (fn) {\n      fn.apply(obj, [obj]);\n    }\n\n    return obj;\n  }\n\n  D.when = function () {\n    if (arguments.length < 2) {\n      var obj = arguments.length ? arguments[0] : undefined;\n\n      if (obj && typeof obj.isResolved === 'function' && typeof obj.isRejected === 'function') {\n        return obj.promise();\n      } else {\n        return D().resolve(obj).promise();\n      }\n    } else {\n      return function (args) {\n        var df = D(),\n            size = args.length,\n            done = 0,\n            rp = new Array(size); // resolve params: params of each resolve, we need to track down them to be able to pass them in the correct order if the master needs to be resolved\n\n        for (var i = 0; i < args.length; i++) {\n          (function (j) {\n            var obj = null;\n\n            if (args[j].done) {\n              args[j].done(function () {\n                rp[j] = arguments.length < 2 ? arguments[0] : arguments;\n\n                if (++done == size) {\n                  df.resolve.apply(df, rp);\n                }\n              }).fail(function () {\n                df.reject(arguments);\n              });\n            } else {\n              obj = args[j];\n              args[j] = new Deferred();\n              args[j].done(function () {\n                rp[j] = arguments.length < 2 ? arguments[0] : arguments;\n\n                if (++done == size) {\n                  df.resolve.apply(df, rp);\n                }\n              }).fail(function () {\n                df.reject(arguments);\n              }).resolve(obj);\n            }\n          })(i);\n        }\n\n        return df.promise();\n      }(arguments);\n    }\n  };\n\n  global.Deferred = D;\n  global.KKJQ = D;\n\n  global.KKJQ.Deferred = function () {\n    return new Deferred();\n  };\n})(window);"},function(n,e,t){t(0)(t(5))},function(n,e){n.exports='function __KKPES() {}\n\nvar KKPES = KKPES ? KKPES : {}; //KKPESClient\n\n__KKPESClient = function __KKPESClient() {\n  var initOptions = {};\n  var sessionUUID = "";\n\n  function ErrorHandler(msg, callerName) {\n    if (KKPES.Logger.getLogStatus()) {\n      if (callerName) {\n        msg = \'Invalid invocation of method \' + callerName + \'; \' + msg;\n      }\n    }\n\n    throw new Error(msg);\n  }\n\n  this.getEnvironment = function () {\n    return \'web\';\n  };\n\n  this.init = function (initOptions) {\n    var dfd = KKJQ.Deferred();\n    setInitParams(initOptions); //initcsrf\n\n    if (initOptions.csrfEnable || initOptions.csrfEnable == undefined) {\n      this.initCSRF(initOptions).then(function (response) {\n        dfd.resolve(response.responseJSON);\n      }, function (error) {\n        //ErrorHandler(JSON.stringify(error.responseText), \'Get csrf token\');\n        dfd.reject(error);\n      });\n    } else {\n      dfd.resolve(true);\n    }\n\n    return dfd.promise();\n  };\n\n  this.initCSRF = function (initOptions) {\n    var dfd = KKJQ.Deferred();\n    var initCSRF = new KKPES.ResourceRequest(KKPES.Config.getCSRFUri(), "GET", "");\n    initCSRF.setTimeout(initOptions.csrfTimeout);\n    initCSRF.sendFormParameters("").then(function (response) {\n      __KKPESTokenStore.setCSRF(response);\n\n      dfd.resolve(response);\n    }, function (error) {\n      dfd.reject(error);\n    });\n    return dfd.promise();\n  };\n\n  this.getLocalization = function () {\n    if (navigator.languages != undefined) return navigator.languages[0];else return navigator.language;\n  }; //todo mock\n  //get access token and send to CAAWS\n\n\n  this.logout = function (realm) {\n    var dfd = KKJQ.Deferred(); // var submitLogin = new KKPESResourceRequest("/v1/" + "logout" , "POST", optionWLResource);\n    // let errorMsg = this.translateService.instant(\'error.system\');\n    // submitLogin.setTimeout(10000);\n    // submitLogin.sendFormParameters(obj.params).then(\n    // \tfunction (response) {\n    // \t\tdfd.resolve(response);\n    // \t},\n    // \tfunction (error) {\n    // \t\tdfd.reject(error.responseText);\n    // \t});\n\n    __KKPES.prototype.KKPESTokenStore.clearAll();\n\n    dfd.resolve(true);\n    return dfd.promise();\n  };\n\n  this.obtainAccessToken = function (aaa) {\n    var dfd = KKJQ.Deferred();\n    dfd.resolve(true);\n    return dfd.promise();\n  };\n\n  this.login = function (obj) {\n    var dfd = KKJQ.Deferred();\n    var submitLogin = new KKPESResourceRequest("/v1/" + "authorization" + "/" + obj.actionCode, "POST", optionWLResource);\n    var errorMsg = this.translateService.instant(\'error.system\');\n    submitLogin.setTimeout(10000);\n    submitLogin.sendFormParameters(obj.params).then(function (response) {\n      dfd.resolve(response);\n    }, function (error) {\n      dfd.reject(error.responseText);\n    });\n    return dfd.promise();\n  };\n\n  function generateUUID() {\n    "use strict";\n\n    var d = new Date().getTime();\n    var uuid = \'\';\n\n    var generate = function generate(c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == \'x\' ? r : r & 0x3 | 0x8).toString(16);\n    };\n\n    uuid = \'xxxyxkkp-xx-xxxxxyyyxxxx\'.replace(/[xy]/g, generate);\n    return uuid;\n  }\n\n  ;\n\n  function setInitParams(params) {\n    // assign params to initOptions inside WL.Client class\n    initOptions = params;\n    var contextRoot = params[\'contextRoot\'];\n    KKPES.Validators.validateDefined(contextRoot, \'__KKPESClient.init\');\n    var appID = params[\'applicationID\'];\n    KKPES.Validators.validateDefined(appID, \'__KKPESClient.init\');\n    var appVersion = params[\'applicationVersion\']; // Pass to config\n\n    KKPES.Config.setContext(contextRoot);\n    KKPES.Config.setApplicationID(appID);\n    KKPES.Config.setApplicationVersion(appVersion); // Init LocalStorageDB\n\n    KKPES.LocalStorageDB.init();\n    sessionUUID = KKPES.LocalStorageDB.getItem(\'UUID\');\n\n    if (sessionUUID === null || sessionUUID === \'\') {\n      sessionUUID = generateUUID();\n      KKPES.LocalStorageDB.setItem(\'UUID\', sessionUUID);\n    }\n\n    console.log(sessionUUID);\n    KKPES.Config.setUUID(sessionUUID);\n  }\n\n  this.getBrowserName = function () {\n    var browserName = navigator.appName;\n    var nAgt = navigator.userAgent;\n    var nameOffset, verOffset, ix;\n\n    if ((verOffset = nAgt.indexOf("Opera")) != -1) {\n      browserName = "Opera";\n    } else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {\n      browserName = "Microsoft Internet Explorer";\n    } else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {\n      browserName = "Chrome";\n    } else if ((verOffset = nAgt.indexOf("Safari")) != -1) {\n      browserName = "Safari";\n    } else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {\n      browserName = "Firefox";\n    } else if ((nameOffset = nAgt.lastIndexOf(\' \') + 1) < (verOffset = nAgt.lastIndexOf(\'/\'))) {\n      browserName = nAgt.substring(nameOffset, verOffset);\n    }\n\n    return browserName;\n  };\n};\n\n__KKPES.prototype.Client = new __KKPESClient();\nKKPES.Client = new __KKPESClient();'},function(n,e,t){t(0)(t(7))},function(n,e){n.exports="var __KKPESConstant = {\n  HEADER_APPLICATION_ID: 'kk-application-id',\n  HEADER_APPLICATION_VERSION: 'kk-application-version',\n  HEADER_ANALYTIC: 'x-analytic',\n  HEADER_COMPLETE_STATUS: 'x-completed',\n  URI_CSRF_INIT: '/protected',\n  ERR_REQUEST_TIMEOUT: 'Error: Request time out',\n  ERR_404: 'Error: 404 not found'\n};\n__KKPES.prototype.Constant = __KKPESConstant;\nKKPES.Constant = __KKPESConstant;"},function(n,e,t){t(0)(t(9))},function(n,e){n.exports="__KKPESLogger = function __KKPESLogger() {\n  isEnable = true;\n\n  this.setLogStatus = function (status) {\n    isEnable = status;\n  };\n\n  this.getLogStatus = function () {\n    return isEnable;\n  };\n};\n\nKKPES.Logger = new __KKPESLogger();"},function(n,e,t){t(0)(t(11))},function(n,e){n.exports='KKPES.Validators = {\n  logAndThrow: function logAndThrow(msg, callerName) {\n    // Logger is not be available in public resources (welcome page).\n    if (KKPES.Logger.getLogStatus()) {\n      if (callerName) {\n        msg = "Invalid invocation of method " + callerName + "; " + msg;\n      }\n\n      if (this.verbose) {\n        console.error(msg); //WL.Logger.error(msg);\n      }\n    }\n\n    alert("log and throw" + msg);\n    throw new Error(msg);\n  },\n  validateDefined: function validateDefined(arg, callerName) {\n    if (typeof arg === \'undefined\' || arg === null) {\n      this.logAndThrow("Invalid argument value \'" + arg + "\', expected not empty string.", callerName);\n    }\n  },\n  isArray: function isArray(object) {\n    return Array.isArray(object);\n  },\n  isJSON: function isJSON(str) {\n    if (str === "") {\n      return false;\n    }\n\n    str = str.replace(/\\\\(?:["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, \'@\');\n    str = str.replace(/"[^"\\\\\\n\\r]*"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \']\');\n    str = str.replace(/(?:^|:|,)(?:\\s*\\[)+/g, \'\');\n    return /^[\\],:{}\\s]*$/.test(str);\n  },\n  isBlank: function isBlank(str) {\n    alert("isblank");\n    return /^\\s*$/.test(str);\n  }\n};'},function(n,e,t){t(0)(t(13))},function(n,e){n.exports='__KKPESConfig = function __KKPESConfig() {\n  var contextRoot = "";\n  var applicationID = "";\n  var applicationVersion = "";\n  var clientUUID = "";\n  var csrfUri = KKPES.Constant.URI_CSRF_INIT;\n\n  this.setContext = function (path) {\n    contextRoot = path;\n  };\n\n  this.getContext = function () {\n    if (contextRoot === "") {\n      contextRoot = "/api";\n    }\n\n    return contextRoot;\n  };\n\n  this.setApplicationID = function (appID) {\n    applicationID = appID;\n  };\n\n  this.getApplicationID = function () {\n    return applicationID;\n  };\n\n  this.setApplicationVersion = function (appVersion) {\n    applicationVersion = appVersion;\n  };\n\n  this.getApplicationVersion = function () {\n    return applicationVersion;\n  };\n\n  this.setUUID = function (uuid) {\n    clientUUID = uuid;\n  };\n\n  this.getUUID = function () {\n    return clientUUID;\n  };\n\n  this.setCSRFUri = function (uri) {\n    csrfUri = KKPES.Constant.URI_CSRF_INIT;\n\n    if (uri !== "") {\n      csrfUri = uri;\n    }\n  };\n\n  this.getCSRFUri = function () {\n    return csrfUri;\n  };\n};\n\n__KKPESTokenStore = function __KKPESTokenStore() {\n  var session_token = "";\n  var csrf_token = "";\n\n  this.setCSRF = function (csrf) {\n    csrf_token = csrf;\n  };\n\n  this.getCSRF = function () {\n    return csrf_token;\n  };\n\n  this.setSessionToken = function (token) {\n    session_token = token;\n  };\n\n  this.getSessionToken = function () {\n    return session_token;\n  };\n\n  this.clearAll = function () {\n    session_token = "";\n    csrf_token = "";\n  };\n};\n\n__KKPES.prototype.KKPESTokenStore = new __KKPESTokenStore();\n__KKPES.prototype.Config = new __KKPESConfig();\nKKPES.Config = new __KKPESConfig();'},function(n,e,t){t(0)(t(15))},function(n,e){n.exports="function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nKKPES.ResourceRequest = function (_url, _method, _options) {\n  var queryParameters = {};\n\n  function ErrorHandler(msg, callerName) {\n    if (KKPES.Logger.getLogStatus()) {\n      if (callerName) {\n        msg = 'Invalid invocation of method ' + callerName + '; ' + msg;\n      }\n    }\n\n    throw new Error(msg);\n  }\n\n  function extractQueryParamFromUrl(_url) {\n    var vars = _url.split('?');\n\n    if (vars.length > 1) {\n      var tmp = vars[1].split('&');\n\n      for (var i = 0; i < tmp.length; i++) {\n        if (true) {\n          var pair = tmp[i].split('=');\n          var values = queryParameters[pair[0]];\n\n          if (values === null || typeof values === 'undefined') {\n            values = [];\n            queryParameters[pair[0]] = values;\n          }\n\n          values[values.length] = pair[1];\n        }\n      }\n    }\n\n    return vars[0];\n  }\n\n  function isAllowRequestMethod(method) {\n    return method === \"GET\" || method === \"POST\" || method === \"PUT\" || method === \"DELETE\";\n  }\n\n  function isUndefinedOrNull(value) {\n    return typeof value === 'undefined' || value === null;\n  }\n\n  var url = _url === null || typeof _url === 'undefined' ? ErrorHandler('Request URL must be specified.', 'KKPES.ResourceRequest') : extractQueryParamFromUrl(_url.trim());\n  var method = typeof _method === 'undefined' || !isAllowRequestMethod(_method) ? ErrorHandler('Request method is invalid or not specified. (KKPES support only : get post put delete)', 'KKPES.ResourceRequest') : _method;\n  var timeout;\n  var headers = {};\n\n  this.getHeader = function (name) {\n    if (name === null || typeof name === 'undefined') {\n      ErrorHandler('Header name is undefined', 'KKPES.ResourceRequest.getHeader');\n    }\n\n    var headerValue = headers[name];\n\n    if (typeof headerValue === 'undefined') {\n      headerValue = __getFirstHeaderByNameNoCase(name).value;\n    }\n\n    if (KKPES.Validators.isArray(headerValue)) {\n      return headerValue[0];\n    }\n\n    return headerValue;\n  };\n\n  this.getTimeout = function () {\n    return timeout;\n  };\n\n  this.setTimeout = function (requestTimeout) {\n    timeout = requestTimeout;\n  };\n\n  this.addHeader = function (name, value) {\n    if (typeof value === 'undefined' || value === null) {\n      ErrorHandler('Error to add header is empty', 'KKPES.ResourceRequest.addHeader');\n    }\n\n    var header = __getFirstHeaderByNameNoCase(name);\n\n    var existingHeaderName = header.name;\n    var existingHeaderValue = header.value;\n\n    if (existingHeaderValue === null) {\n      headers[name] = value;\n    } else {\n      if (KKPES.Validators.isArray(existingHeaderValue)) {\n        for (var idx in existingHeaderValue) {\n          if (existingHeaderValue[idx].toString() === value.toString()) {\n            return;\n          }\n        }\n\n        existingHeaderValue.push(value);\n      } else {\n        var array = [];\n        array.push(existingHeaderValue);\n        array.push(value);\n        headers[existingHeaderName] = array;\n      }\n    }\n  };\n\n  this.sendFormParameters = function (json) {\n    if (_typeof(json) !== \"object\") {\n      json = {};\n    }\n\n    this.addHeader('Content-Type', 'application/json');\n    this.addHeader(KKPES.Constant.HEADER_ANALYTIC, JSON.stringify(this.setAnalyticHeader(json)));\n    this.addHeader(KKPES.Constant.HEADER_APPLICATION_ID, KKPES.Config.getApplicationID());\n    this.addHeader(KKPES.Constant.HEADER_APPLICATION_VERSION, KKPES.Config.getApplicationVersion());\n    contentString = JSON.stringify(json);\n    return sendRequestAsync(contentString, 0, 0);\n  };\n\n  this.setAnalyticHeader = function (json) {\n    var analyticsHeader = {};\n    analyticsHeader.type = 'analytic';\n    analyticsHeader.uuid = KKPES.Config.getUUID();\n    analyticsHeader.appID = KKPES.Config.getApplicationID();\n    analyticsHeader.appVersion = KKPES.Config.getApplicationVersion();\n    analyticsHeader.clientLang = KKPES.Client.getLocalization();\n    analyticsHeader.browser = KKPES.Client.getBrowserName();\n    analyticsHeader.clientDateTime = new Date(); //set action code\n\n    analyticsHeader.trackingObj = {};\n\n    if (_typeof(json.header) === \"object\" || json.header !== \"\") {\n      analyticsHeader.trackingObj = json.header;\n    }\n\n    if (json.actionCode !== \"\" || json.actionCode != 'undefined') {\n      analyticsHeader.trackingObj.actionCode = json.actionCode;\n    }\n\n    return analyticsHeader;\n  };\n\n  function sendRequestAsync(contentString, attempt, conflictAttemptCounter) {\n    var dfd = KKJQ.Deferred();\n\n    __sendToXHR(url, contentString, attempt, conflictAttemptCounter).then(function (response) {\n      //todo set analytics here\n      dfd.resolve(response);\n    }, function (error) {\n      dfd.reject(error);\n    });\n\n    return dfd.promise();\n  }\n\n  function encodeFormParameters(json) {\n    if (json === null || typeof json === 'undefined') {\n      return '';\n    }\n\n    var result = '';\n\n    for (var key in json) {\n      var value = json[key];\n      result += encodeURIComponent(key) + '=' + encodeURIComponent(value);\n      result += '&';\n    }\n\n    if (result.length > 0 && result[result.length - 1] === '&') {\n      result = result.substring(0, result.length - 1);\n    }\n\n    return result;\n  }\n\n  function __sendToXHR(serverUrl, contentString, attempt, conflictAttemptCounter) {\n    var dfd = KKJQ.Deferred();\n    var xhr = new XMLHttpRequest();\n    var serverUrl = KKPES.Config.getContext() + serverUrl;\n    xhr.open(method, serverUrl, true);\n\n    if (typeof timeout !== 'undefined') {\n      xhr.timeout = timeout;\n    }\n\n    addRequestHeaders(xhr);\n\n    xhr.onreadystatechange = function () {\n      if (this.readyState === 4) {\n        var transport = this;\n        transport.responseJSON = {}; // timeout state\n\n        if (this.status === 0) {\n          //   var errorCode = KKPES.Constant.ERR_REQUEST_TIMEOUT;\n          // handle errors - timeout, unresponsive host and unexpected error\n          transport.status = 0;\n          transport.responseJSON = {\n            errorCode: \"ERR_REQUEST_TIMEOUT\",\n            errorMsg: KKPES.Constant.ERR_REQUEST_TIMEOUT\n          };\n          dfd.reject(transport);\n        }\n\n        if (!checkHttpStatus(this.status)) {\n          var newStatus = \"ERR_\" + this.status;\n          transport.responseJSON = {\n            errorCode: KKPES.Constant[newStatus],\n            errorMsg: this.responseText,\n            isSuccessful: isSuccess()\n          };\n          dfd.reject(transport);\n          return dfd.promise();\n        } //Convert to json\n\n\n        transport.responseJSON = transport.response;\n\n        if (_typeof(transport.response) !== \"object\") {\n          transport.responseJSON = JSON.parse(transport.response);\n        }\n\n        transport.responseJSON.isSuccessful = isSuccess();\n        var exposeResponse = {\n          responseJSON: transport.responseJSON\n        };\n\n        if (this.status >= 200 && this.status <= 299) {\n          if (isSuccess()) {\n            dfd.resolve(exposeResponse);\n          } else {\n            //transfrom error\n            exposeResponse.responseJSON = __errorBackendResponse(transport.responseJSON);\n            dfd.resolve(exposeResponse);\n          }\n        } else {\n          exposeResponse.responseJSON = __errorEdgeResponse(transport.responseJSON);\n          dfd.reject(exposeResponse);\n        }\n      }\n\n      function isSuccess() {\n        if (transport.getResponseHeader(KKPES.Constant.HEADER_COMPLETE_STATUS) == 'true') {\n          return true;\n        }\n\n        return false;\n      }\n    };\n\n    sendRequest();\n\n    function sendRequest() {\n      xhr.send(method === 'GET' ? null : contentString, true);\n    }\n\n    return dfd.promise();\n  }\n\n  function checkHttpStatus(resp) {\n    if (resp === 404 || resp === 500) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function isCallSuccess() {\n    return;\n  }\n\n  function isJSON(str) {\n    return KKPES.Validators.isJSON(str);\n  }\n\n  function addRequestHeaders(xhr) {\n    for (var headerName in headers) {\n      var headerValue = headers[headerName];\n      xhr.setRequestHeader(headerName, headerValue.toString());\n    }\n  }\n\n  function __errorBackendResponse(errResponse) {\n    var http_body = JSON.parse(errResponse.error_response.http_body);\n    var error_respone = {\n      result: http_body\n    };\n    return error_respone;\n  }\n\n  function __errorEdgeResponse(errResponse) {\n    var error_respone = {\n      result: errResponse.error_response\n    };\n    return error_respone;\n  }\n\n  function __getFirstHeaderByNameNoCase(name) {\n    for (var headerName in headers) {\n      if (headerName.toLowerCase() === name.toLowerCase()) {\n        return {\n          name: headerName,\n          value: headers[headerName]\n        };\n      }\n    }\n\n    return {\n      name: null,\n      value: null\n    };\n  }\n};\n\nwindow.KKPESResourceRequest = KKPES.ResourceRequest;"},function(n,e,t){t(0)(t(17))},function(n,e){n.exports="__KKPESLocalStorageDB = function __KKPESLocalStorageDB() {\n  var appNamePrefix;\n  var storage = window.localStorage;\n\n  this.init = function () {\n    appNamePrefix = KKPES.Config.getApplicationID();\n  };\n  /**\n   * Sets an item in the database\n   * @param key\n   * @param value\n   * @param options {{session : boolean, global : boolean}}\n   * @returns {*}\n   */\n\n\n  this.setItem = function (key, value, options) {\n    var finalOptions = initOptions(options);\n    var finalKey = buildKey(key, finalOptions);\n    var finalValue = value ? JSON.stringify(value) : null;\n    storage.setItem(finalKey, finalValue);\n  };\n  /**\n   * Gets an item in the database\n   * @param key\n   * @param options {{session : boolean, global : boolean}}\n   * @returns {string - JSON representation of value for given key}\n   */\n\n\n  this.getItem = function (key, options) {\n    var finalOptions = initOptions(options);\n    var finalKey = buildKey(key, finalOptions);\n    var value = storage.getItem(finalKey);\n    return value ? JSON.parse(value) : null;\n  };\n  /**\n   * Removes an item in the database\n   * @param key\n   * @param options {{session : boolean, global : boolean}}\n   * @returns {*}\n   */\n\n\n  this.removeItem = function (key, options) {\n    var finalOptions = initOptions(options);\n    var finalKey = buildKey(key, finalOptions);\n    storage.removeItem(finalKey);\n  };\n  /**\n   * Takes the options the user entered (if any) and appends them to the default\n   * options, overriding the default values\n   * @param userOptions\n   * @returns {{global: boolean, session: boolean}}\n   */\n\n\n  function initOptions(userOptions) {\n    var options = {\n      'session': false,\n      'global': false\n    };\n\n    for (var property in userOptions) {\n      options[property] = userOptions[property];\n    } // Init the storage\n\n\n    storage = options.session ? window.sessionStorage : window.localStorage;\n    return options;\n  }\n\n  function buildKey(key, options) {\n    return options.global ? key : appNamePrefix + '.' + key;\n  }\n};\n\nKKPES.LocalStorageDB = new __KKPESLocalStorageDB();"}]);